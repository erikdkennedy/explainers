{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0, 0.7) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.2300*2., 1e-5);\nuv = rotate(uv, (0.4968 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"aspectRatio":0.36,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"trackMouse":0.07,"anchorPoint":8,"mouseMomentum":1,"mask":0,"maskDepthLayer":1,"layerType":"shape","width":3,"widthMode":0,"height":3,"heightMode":0,"left":0,"top":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.12156862745098039, 0.00392156862745098, 0.24313725490196078);\ncase 1: return vec3(1, 0.6274509803921569, 0.07058823529411765);\ncase 2: return vec3(0.9411764705882353, 0.3803921568627451, 0.12549019607843137);\ncase 3: return vec3(0.48627450980392156, 0.027450980392156862, 0.0784313725490196);\ncase 4: return vec3(0.09803921568627451, 0, 0.11764705882352941);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.2781;\ncase 1: return 0.3250;\ncase 2: return 0.4094;\ncase 3: return 0.6062;\ncase 4: return 1.0000;\ncase 5: return 1.2500;\ncase 6: return 1.5000;\ncase 7: return 1.7500;\ncase 8: return 2.0000;\ncase 9: return 2.2500;\ncase 10: return 2.5000;\ncase 11: return 2.7500;\ncase 12: return 3.0000;\ncase 13: return 3.2500;\ncase 14: return 3.5000;\ncase 15: return 3.7500;\ndefault: return 0.0;\n}\n}uniform vec2 uArtboardResolution;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);vec3 lms1 = safeCbrt(kCONEtoLMS * lin1);\nvec3 lms2 = safeCbrt(kCONEtoLMS * lin2);\nvec3 lms = mix(lms1, lms2, a);\nlms *= 1.0 + 0.025 * a * (1.0 - a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (5 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 5 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 5 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(5 - 1, 15));\n}vec3 getRadialGradientColor(vec2 p, vec2 halfSize) {\nfloat radius = max(halfSize.x, halfSize.y);\nfloat pos = 1.0 - (length(p) / max(radius, 0.00001));\nreturn getGradientColor(pos);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;float angle = 0.0000 * TAU;\nreturn getRadialGradientColor(p, halfSize);return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdEllipse(vec2 p, vec2 ab) {\nvec2 q = p / ab;\nreturn (length(q) - 1.0) * min(ab.x, ab.y);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;return sdEllipse(p, vec2(max(halfSize.x, 0.00001), max(halfSize.y, 0.00001)));\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 3.0000 * uArtboardResolution.x;\nfloat absHeight = 3.0000 * uArtboardResolution.y;if (0 == 2) {\nabsWidth = absHeight * 0.3600;\n} else if (0 == 2) {\nabsHeight = absWidth / 0.3600;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.0000, 0.0000) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = rotate2D(canvasPosPx - (elementPosPx + elementSizePx * 0.5), 0.0000 * -TAU) + elementSizePx * 0.5;\nvec2 localSize;\nlocalSize = elementSizePx;\nvec2 centerPx;\ncenterPx = elementPosPx + elementSizePx * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 getCompositeOutput(vec2 uv) {\nvec4 background = vec4(0.0);background = texture(uBgTexture, vTextureCoord);vec4 color = sampleShape(uv);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0700;uv -= pos;fragColor = getCompositeOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1400,"_y":400}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":0.36}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fbm","usesPingPong":false,"speed":0.33,"trackMouse":0,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t;\n}vec3 hash33(vec3 p3) {\np3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\np3 += dot(p3, p3.yxz + 19.19);\nreturn -1.0 + 2.0 * fract(vec3(\n(p3.x + p3.y) * p3.z,\n(p3.x + p3.z) * p3.y,\n(p3.y + p3.z) * p3.x\n));\n}float perlin_noise(vec3 p) {\nvec3 pi = floor(p);\nvec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0)));\nfloat n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0)));\nfloat n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0)));\nfloat n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0)));\nfloat n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0)));\nfloat n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0)));\nfloat n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0)));\nfloat n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x);\nfloat nx01 = mix(n001, n101, w.x);\nfloat nx10 = mix(n010, n110, w.x);\nfloat nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y);\nfloat nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz;\n}\nconst float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}mat2 rotHalf = mat2(cos(0.5), sin(0.5),\n-sin(0.5), cos(0.5));float fbm (in vec3 st) {\nfloat value = 0.0;\nfloat amp = .25;\nfloat frequency = 0.;\nfloat aM = (0.1 + 2.0000 * .65);\nvec2 shift = vec2(100.0);\nfor (int i = 0; i < 3; i++) {\nvalue += amp * perlin_noise(st);\nst.xy *= rotHalf * 2.5;\nst.xy += shift;\namp *= aM;\n}\nreturn value;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat multiplier = 6.0 * (1.0000 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.463519313304721, 0.5051502145922746) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.463519313304721, 0.5051502145922746), mPos, floor(1.0000));\nfloat mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));\nvec2 skew = mix(vec2(1), vec2(1, 0), 0.0000);\nvec2 st = ((uv - pos) * vec2(aspectRatio, 1)) * multiplier * aspectRatio;\nst = rot(0.2430 * -2. * PI) * st * skew;\nvec2 drift = vec2(0, uTime * 0.005) * (1.0000 * 2.);float time = uTime * 0.025;vec2 r = vec2(\nfbm(vec3(st - drift + vec2(1.7, 9.2), 0.0000*25. + time)),\nfbm(vec3(st - drift + vec2(8.2, 1.3), 0.0000*25. + time))\n);float f = fbm(vec3(st + r - drift, 0.0000*25. + time)) * 1.0000;vec2 offset = (f * 2. + (r * 1.0000));vec4 color = texture(uTexture, uv + offset * mDist);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"fbm"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"radialBlur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}vec4 RadialBlur(sampler2D tex, vec2 uv) {\nif (0.4700 == 0.0) {\nreturn texture(tex, uv);\n}\nvec2 pos = vec2(0, 1) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 dir = uv - pos;\ndir.x *= aspectRatio;\nfloat dist = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1));\ndist = ease(0, max(0.,1.-dist * 4. * (1. - 1.0000)));\nif (0 == 1) {\ndist = max(0., (0.5 - dist));\n}float amount = (0.4700 + 0.2) * dist * 0.04;\nif(0 == 1) amount *= 0.5;\nif(0 == 2) amount *= 0.25;\nif (amount < 0.0001) {\nreturn texture(tex, uv);\n}\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nvec2 toUv = uv - pos;\nvec2 toUvAR = vec2(toUv.x * aspectRatio, toUv.y);\nfloat radius = length(toUvAR);\nfloat baseAngle = atan(toUvAR.y, toUvAR.x);float angleStep = amount;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat step = float(i) * angleStep;float a1 = baseAngle + step;\nvec2 rot1AR = radius * vec2(cos(a1), sin(a1));\nvec2 rot1 = vec2(rot1AR.x / aspectRatio, rot1AR.y) + pos;float a2 = baseAngle - step;\nvec2 rot2AR = radius * vec2(cos(a2), sin(a2));\nvec2 rot2 = vec2(rot2AR.x / aspectRatio, rot2AR.y) + pos;vec4 sample1 = texture(tex, rot1);\nvec4 sample2 = texture(tex, rot2);color += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}color = color / total_weight;\nif(0 == 3) {\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\n}\nreturn color;\n}vec4 radialBlurPass(vec2 uv) {return RadialBlur(uTexture, uv);\n}vec4 getPassColor(vec2 uv) {\nreturn radialBlurPass(uv);\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = getPassColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}vec4 RadialBlur(sampler2D tex, vec2 uv) {\nif (0.4700 == 0.0) {\nreturn texture(tex, uv);\n}\nvec2 pos = vec2(0, 1) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 dir = uv - pos;\ndir.x *= aspectRatio;\nfloat dist = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1));\ndist = ease(0, max(0.,1.-dist * 4. * (1. - 1.0000)));\nif (0 == 1) {\ndist = max(0., (0.5 - dist));\n}float amount = (0.4700 + 0.2) * dist * 0.04;\nif(1 == 1) amount *= 0.5;\nif(1 == 2) amount *= 0.25;\nif (amount < 0.0001) {\nreturn texture(tex, uv);\n}\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nvec2 toUv = uv - pos;\nvec2 toUvAR = vec2(toUv.x * aspectRatio, toUv.y);\nfloat radius = length(toUvAR);\nfloat baseAngle = atan(toUvAR.y, toUvAR.x);float angleStep = amount;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat step = float(i) * angleStep;float a1 = baseAngle + step;\nvec2 rot1AR = radius * vec2(cos(a1), sin(a1));\nvec2 rot1 = vec2(rot1AR.x / aspectRatio, rot1AR.y) + pos;float a2 = baseAngle - step;\nvec2 rot2AR = radius * vec2(cos(a2), sin(a2));\nvec2 rot2 = vec2(rot2AR.x / aspectRatio, rot2AR.y) + pos;vec4 sample1 = texture(tex, rot1);\nvec4 sample2 = texture(tex, rot2);color += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}color = color / total_weight;\nif(1 == 3) {\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\n}\nreturn color;\n}vec4 radialBlurPass(vec2 uv) {return RadialBlur(uTexture, uv);\n}vec4 getPassColor(vec2 uv) {\nreturn radialBlurPass(uv);\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = getPassColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}vec4 RadialBlur(sampler2D tex, vec2 uv) {\nif (0.4700 == 0.0) {\nreturn texture(tex, uv);\n}\nvec2 pos = vec2(0, 1) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 dir = uv - pos;\ndir.x *= aspectRatio;\nfloat dist = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1));\ndist = ease(0, max(0.,1.-dist * 4. * (1. - 1.0000)));\nif (0 == 1) {\ndist = max(0., (0.5 - dist));\n}float amount = (0.4700 + 0.2) * dist * 0.04;\nif(2 == 1) amount *= 0.5;\nif(2 == 2) amount *= 0.25;\nif (amount < 0.0001) {\nreturn texture(tex, uv);\n}\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nvec2 toUv = uv - pos;\nvec2 toUvAR = vec2(toUv.x * aspectRatio, toUv.y);\nfloat radius = length(toUvAR);\nfloat baseAngle = atan(toUvAR.y, toUvAR.x);float angleStep = amount;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat step = float(i) * angleStep;float a1 = baseAngle + step;\nvec2 rot1AR = radius * vec2(cos(a1), sin(a1));\nvec2 rot1 = vec2(rot1AR.x / aspectRatio, rot1AR.y) + pos;float a2 = baseAngle - step;\nvec2 rot2AR = radius * vec2(cos(a2), sin(a2));\nvec2 rot2 = vec2(rot2AR.x / aspectRatio, rot2AR.y) + pos;vec4 sample1 = texture(tex, rot1);\nvec4 sample2 = texture(tex, rot2);color += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}color = color / total_weight;\nif(2 == 3) {\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\n}\nreturn color;\n}vec4 radialBlurPass(vec2 uv) {return RadialBlur(uTexture, uv);\n}vec4 getPassColor(vec2 uv) {\nreturn radialBlurPass(uv);\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = getPassColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;vec4 finalPass(vec2 uv) {\nif (0.4700 == 0.00) {\nreturn texture(uBgTexture, uv);\n}\nvec4 blurredColor = texture(uTexture, uv);\nvec4 originalColor = texture(uBgTexture, uv);\nvec2 pos = vec2(0, 1) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));\nif (0 == 1) {\ndist = max(0., (0.5 - dist));\n}return mix(originalColor, blurredColor, (0.4700 * dist > 0.001) ? 1.0 : 0.0);\n}vec4 getPassColor(vec2 uv) {\nreturn finalPass(uv);\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = getPassColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"includeBg":true}]},"id":"radial_blur"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"coloration","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;vec3 getFilteredColor(vec3 color) {\nreturn color;\n}float hueToRgb(float p, float q, float t) {\nif (t < 0.0) t += 1.0;\nif (t > 1.0) t -= 1.0;\nif (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;\nif (t < 1.0 / 2.0) return q;\nif (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;\nreturn p;\n}vec3 hslToRgb(vec3 hsl) {\nfloat h = hsl.x;\nfloat s = hsl.y;\nfloat l = hsl.z;\nvec3 rgb = vec3(l);\nif (s != 0.0) {\nfloat q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\nfloat p = 2.0 * l - q;\nrgb.r = hueToRgb(p, q, h + 1.0 / 3.0);\nrgb.g = hueToRgb(p, q, h);\nrgb.b = hueToRgb(p, q, h - 1.0 / 3.0);\n}\nreturn rgb;\n}vec3 rgbToHsl(vec3 rgb) {\nfloat max = max(max(rgb.r, rgb.g), rgb.b);\nfloat min = min(min(rgb.r, rgb.g), rgb.b);\nfloat h, s, l = (max + min) / 2.0;if (max == min) {\nh = s = 0.0;\n} else {\nfloat d = max - min;\ns = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);\nif (max == rgb.r) {\nh = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0);\n} else if (max == rgb.g) {\nh = (rgb.b - rgb.r) / d + 2.0;\n} else if (max == rgb.b) {\nh = (rgb.r - rgb.g) / d + 4.0;\n}\nh /= 6.0;\n}return vec3(h, s, l);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}color.rgb = rgbToHsl(color.rgb);\ncolor.x = fract(color.x + 1.0000);\ncolor.y = clamp(color.y * 0.8600, 0.0, 1.0);\ncolor.z = clamp(color.z + 0.0300, 0.0, 1.0);\ncolor.rgb = hslToRgb(color.rgb);\ncolor.rgb = getFilteredColor(color.rgb);color.rgb = 1.1200 * (color.rgb - 0.5) + 0.5;color.r = clamp(color.r + -0.1400, 0.0, 1.0);\ncolor.b = clamp(color.b - -0.1400, 0.0, 1.0);color.g = clamp(color.g - 0.0000, 0.0, 1.0);\ncolor.r = clamp(color.r + 0.0000 * 0.5, 0.0, 1.0);\ncolor.b = clamp(color.b + 0.0000 * 0.5, 0.0, 1.0);color = vec4(clamp(color.rgb, 0.0, 1.0), color.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"adjust"}],"options":{"name":"Saturn's rings","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.5","id":"rn2JFkOAbWLcxXSyOBH6"}